// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: event.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    content,
    place,
    description,
    start_time,
    end_time
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, content, place, description, start_time, end_time, created_at, updated_at
`

type CreateEventParams struct {
	Content     string             `json:"content"`
	Place       string             `json:"place"`
	Description string             `json:"description"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
	EndTime     pgtype.Timestamptz `json:"end_time"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Content,
		arg.Place,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Place,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEventReminder = `-- name: CreateEventReminder :one
INSERT INTO event_reminders (
    event_id,
    remind_before
) VALUES (
    $1, $2
)
RETURNING id, event_id, remind_before, notified, created_at
`

type CreateEventReminderParams struct {
	EventID      int64 `json:"event_id"`
	RemindBefore int32 `json:"remind_before"`
}

func (q *Queries) CreateEventReminder(ctx context.Context, arg CreateEventReminderParams) (EventReminder, error) {
	row := q.db.QueryRow(ctx, createEventReminder, arg.EventID, arg.RemindBefore)
	var i EventReminder
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.RemindBefore,
		&i.Notified,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const deleteEventReminder = `-- name: DeleteEventReminder :exec
DELETE FROM event_reminders
WHERE id = $1
`

func (q *Queries) DeleteEventReminder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteEventReminder, id)
	return err
}

const getAllEvents = `-- name: GetAllEvents :many
SELECT 
    e.id,
    e.content,
    e.place,
    e.description,
    e.start_time,
    e.end_time,
    e.created_at,
    e.updated_at,
    er.id as reminder_id,
    er.remind_before,
    er.notified,
    er.created_at as reminder_created_at
FROM events e
LEFT JOIN event_reminders er ON e.id = er.event_id
ORDER BY e.start_time ASC, er.remind_before ASC
`

type GetAllEventsRow struct {
	ID                int64              `json:"id"`
	Content           string             `json:"content"`
	Place             string             `json:"place"`
	Description       string             `json:"description"`
	StartTime         pgtype.Timestamptz `json:"start_time"`
	EndTime           pgtype.Timestamptz `json:"end_time"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ReminderID        pgtype.Int8        `json:"reminder_id"`
	RemindBefore      pgtype.Int4        `json:"remind_before"`
	Notified          pgtype.Bool        `json:"notified"`
	ReminderCreatedAt pgtype.Timestamptz `json:"reminder_created_at"`
}

func (q *Queries) GetAllEvents(ctx context.Context) ([]GetAllEventsRow, error) {
	rows, err := q.db.Query(ctx, getAllEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllEventsRow
	for rows.Next() {
		var i GetAllEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Place,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderID,
			&i.RemindBefore,
			&i.Notified,
			&i.ReminderCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventByID = `-- name: GetEventByID :one
SELECT 
    e.id,
    e.content,
    e.place,
    e.description,
    e.start_time,
    e.end_time,
    e.created_at,
    e.updated_at,
    er.id as reminder_id,
    er.remind_before,
    er.notified,
    er.created_at as reminder_created_at
FROM events e
LEFT JOIN event_reminders er ON e.id = er.event_id
WHERE e.id = $1
ORDER BY er.remind_before ASC
`

type GetEventByIDRow struct {
	ID                int64              `json:"id"`
	Content           string             `json:"content"`
	Place             string             `json:"place"`
	Description       string             `json:"description"`
	StartTime         pgtype.Timestamptz `json:"start_time"`
	EndTime           pgtype.Timestamptz `json:"end_time"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ReminderID        pgtype.Int8        `json:"reminder_id"`
	RemindBefore      pgtype.Int4        `json:"remind_before"`
	Notified          pgtype.Bool        `json:"notified"`
	ReminderCreatedAt pgtype.Timestamptz `json:"reminder_created_at"`
}

func (q *Queries) GetEventByID(ctx context.Context, id int64) (GetEventByIDRow, error) {
	row := q.db.QueryRow(ctx, getEventByID, id)
	var i GetEventByIDRow
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Place,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderID,
		&i.RemindBefore,
		&i.Notified,
		&i.ReminderCreatedAt,
	)
	return i, err
}

const getEventRemindersByEventID = `-- name: GetEventRemindersByEventID :many
SELECT 
    id,
    event_id,
    remind_before,
    notified,
    created_at
FROM event_reminders
WHERE event_id = $1
ORDER BY remind_before ASC
`

func (q *Queries) GetEventRemindersByEventID(ctx context.Context, eventID int64) ([]EventReminder, error) {
	rows, err := q.db.Query(ctx, getEventRemindersByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventReminder
	for rows.Next() {
		var i EventReminder
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.RemindBefore,
			&i.Notified,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventRemindersToNotify = `-- name: GetEventRemindersToNotify :many
SELECT 
    er.id,
    er.event_id,
    er.remind_before,
    er.notified,
    er.created_at,
    e.content,
    e.place,
    e.description,
    e.start_time,
    e.end_time
FROM event_reminders er
JOIN events e ON er.event_id = e.id
WHERE er.notified = false
    AND e.start_time <= NOW() + INTERVAL '1 minute' * er.remind_before
ORDER BY e.start_time ASC
`

type GetEventRemindersToNotifyRow struct {
	ID           int64              `json:"id"`
	EventID      int64              `json:"event_id"`
	RemindBefore int32              `json:"remind_before"`
	Notified     bool               `json:"notified"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	Content      string             `json:"content"`
	Place        string             `json:"place"`
	Description  string             `json:"description"`
	StartTime    pgtype.Timestamptz `json:"start_time"`
	EndTime      pgtype.Timestamptz `json:"end_time"`
}

func (q *Queries) GetEventRemindersToNotify(ctx context.Context) ([]GetEventRemindersToNotifyRow, error) {
	rows, err := q.db.Query(ctx, getEventRemindersToNotify)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventRemindersToNotifyRow
	for rows.Next() {
		var i GetEventRemindersToNotifyRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.RemindBefore,
			&i.Notified,
			&i.CreatedAt,
			&i.Content,
			&i.Place,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByDateRange = `-- name: GetEventsByDateRange :many
SELECT 
    e.id,
    e.content,
    e.place,
    e.description,
    e.start_time,
    e.end_time,
    e.created_at,
    e.updated_at,
    er.id as reminder_id,
    er.remind_before,
    er.notified,
    er.created_at as reminder_created_at
FROM events e
LEFT JOIN event_reminders er ON e.id = er.event_id
WHERE e.start_time >= $1 AND e.end_time <= $2
ORDER BY e.start_time ASC, er.remind_before ASC
`

type GetEventsByDateRangeParams struct {
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
}

type GetEventsByDateRangeRow struct {
	ID                int64              `json:"id"`
	Content           string             `json:"content"`
	Place             string             `json:"place"`
	Description       string             `json:"description"`
	StartTime         pgtype.Timestamptz `json:"start_time"`
	EndTime           pgtype.Timestamptz `json:"end_time"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ReminderID        pgtype.Int8        `json:"reminder_id"`
	RemindBefore      pgtype.Int4        `json:"remind_before"`
	Notified          pgtype.Bool        `json:"notified"`
	ReminderCreatedAt pgtype.Timestamptz `json:"reminder_created_at"`
}

func (q *Queries) GetEventsByDateRange(ctx context.Context, arg GetEventsByDateRangeParams) ([]GetEventsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getEventsByDateRange, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsByDateRangeRow
	for rows.Next() {
		var i GetEventsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Place,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderID,
			&i.RemindBefore,
			&i.Notified,
			&i.ReminderCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET 
    content = $2,
    place = $3,
    description = $4,
    start_time = $5,
    end_time = $6
WHERE id = $1
RETURNING id, content, place, description, start_time, end_time, created_at, updated_at
`

type UpdateEventParams struct {
	ID          int64              `json:"id"`
	Content     string             `json:"content"`
	Place       string             `json:"place"`
	Description string             `json:"description"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
	EndTime     pgtype.Timestamptz `json:"end_time"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.ID,
		arg.Content,
		arg.Place,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Place,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEventReminderNotified = `-- name: UpdateEventReminderNotified :exec
UPDATE event_reminders
SET notified = $2
WHERE id = $1
`

type UpdateEventReminderNotifiedParams struct {
	ID       int64 `json:"id"`
	Notified bool  `json:"notified"`
}

func (q *Queries) UpdateEventReminderNotified(ctx context.Context, arg UpdateEventReminderNotifiedParams) error {
	_, err := q.db.Exec(ctx, updateEventReminderNotified, arg.ID, arg.Notified)
	return err
}
